<html><head><title>Maze Project Write-up</title><style type="text/css">ol{margin:0;padding:0}p{margin:0}.c5{line-height:1.15;text-indent:-36.0pt;direction:ltr;margin-left:36.0pt}.c1{padding-left:0pt;line-height:1.15;direction:ltr;margin-left:36.0pt}.c2{line-height:1.15;text-indent:0pt;direction:ltr}.c4{color:#000000;font-size:14pt;font-family:Arial}.c17{color:#000000;font-size:24pt;font-family:Arial}.c7{padding-top:11.0pt;text-align:center;padding-bottom:2.0pt}.c12{padding-top:24.0pt;text-align:center;padding-bottom:6.0pt}.c0{color:#000000;font-size:11pt;font-family:Arial}.c11{color:#000000;font-size:10pt;font-family:Arial}.c10{padding-top:14.0pt;padding-bottom:4.0pt}.c9{padding-top:11.0pt;padding-bottom:2.0pt}.c18{padding-top:10.0pt;padding-bottom:2.0pt}.c8{font-style:italic}.c14{list-style-type:disc}.c6{text-align:right}.c16{background-color:#ffffff}.c13{text-align:center}.c3{font-weight:bold}.c15{list-style-type:decimal}</style></head><body class="c16"><p class="c2 c6"><span class="c0">Jeff McGlynn</span></p><p class="c2 c6"><span class="c0">#72846979</span></p><p class="c2 c6"><span class="c0">&nbsp;</span></p><p class="c2 c6"><span class="c0">Jesus Quezada</span></p><p class="c2 c6"><span class="c0">#50022121</span></p><p class="c2 c6"><span class="c0">&nbsp;</span></p><p class="c2 c12"><a name="h.5x8i5f-xd0agf"></a><span class="c3 c17">Maze Project Write-up</span></p><p class="c2 c7"><a name="h.bu72e8-ktuut7"></a><span class="c0 c3">CS 171</span></p><p class="c2 c7"><a name="h.wq253m-6cif49"></a><span class="c0 c3">November 29th, 2010</span></p><p class="c2 c10"><a name="h.yyx956-5xznrn"></a><span class="c4 c3">Maze Generator</span></p><p class="c2 c9"><a name="h.7v3jjl-tj9sxq"></a><span class="c0 c3">Wilson&rsquo;s Algorithm</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">Wilson&rsquo;s algorithm is the first solver that we implemented. Although it runs very slowly, it manages to stay within the six second time limit for generating a 500 x 500 maze. The generator creates the mazes very uniformly, and typically does so in 2-4 seconds in our testing environment.</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">The algorithm works by choosing an arbitrary point in the maze and performing a &ldquo;loop-erased random walk&rdquo; until running into a node that has already been generated, or &ldquo;connected&rdquo; to the maze. &nbsp;Once the path is created it is retraced and each node in the path is marked as &ldquo;connected.&rdquo; &nbsp;If the path self-intersects only the last direction is retraced, allowing the generator to create a path without worrying about resolving intersections.</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">The algorithm is as follows:</span></p><ol class="c15"><li class="c1" value="1"><span class="c0">Pick a start node for the maze, and mark it as &ldquo;connected.&rdquo;</span></li><li class="c1"><span class="c0">Begin looping until no more nodes need to be connected.</span></li><li class="c1"><span class="c0">Pick an arbitrary unconnected point.</span></li><li class="c1"><span class="c0">Randomly trace a path by visiting one of the four-connected nodes adjacent to the current node.</span></li><li class="c1"><span class="c0">If the current node is &ldquo;connected&rdquo; we have completed a path. &nbsp;Resolve self-intersections and find the shortest path from the first point in our path to the end. &nbsp;Add all nodes in this path to the maze and mark them as &ldquo;connected.&rdquo;</span></li><li class="c1"><span class="c0">If the current node is not connected repeat step 4 and continue tracing the path.</span></li></ol><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2 c18"><a name="h.16s6am-rl4g8"></a><span class="c3 c11">Optimizations</span></p><p class="c2"><span class="c0">Our implementation is designed to be memory-efficient. &nbsp;The random walks have no definite length and will continue until intersecting a connected node of the maze. &nbsp;To reduce memory usage a table is created to store the direction of movement at each node in the path, instead of keeping track of the entire path.</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">This is inspired by the table of last visited nodes created by Dijkstra&#39;s algorithm but is modified to only contain the information relevant to trace the path.</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">Example maze generated with Wilson&rsquo;s algorithm at 70x70 size:</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2 c13"><img height="583.0" src="images/image3.png" width="582.0"></p><p class="c2 c9"><a name="h.7g1o93-pbxr8s"></a><span class="c0 c3">Eller&rsquo;s Algorithm</span></p><p class="c2"><span class="c0">This algorithm was implemented to test different generation algorithms. &nbsp;It is significantly faster than the Wilson generator, creating a 500x500 maze in 0.5 seconds.</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">Eller&rsquo;s algorithm generates mazes in linear time but does not generate as uniformly as Wilson&rsquo;s algorithm. &nbsp;The maze tends to favor vertical movements and the right-most column and bottom row appear less random than other columns or rows.</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">The algorithm is as follows:</span></p><ol class="c15"><li class="c1" value="1"><span class="c0">Iterate over each row of the maze. &nbsp;In the first row randomly connect some of the cells on the top row of the maze.</span></li><li class="c1"><span class="c0">Make a list of the sets of connected cells. A cell which is not connected to any other cell is in a set by itself.</span></li><li class="c1"><span class="c0">For each connected set, make at least one connection between it and the next row. Update the connection sets. A cell in the next row which is not connected to other cells constitutes a new connection set.</span></li><li class="c1"><span class="c0">If the next row is not the bottom row: On the next row, randomly connect some of the cells and update the connection sets, but do not connect two cells that are already in the same set. &nbsp;Return to step 3. </span></li><li class="c1"><span class="c0">On the bottom row, connect each pair of adjacent cells if they are not already in the same set.</span></li></ol><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">This algorithm is not used in our final generator and was implemented to be used for comparison with other algorithms. &nbsp;We ultimately did not choose this algorithm because of the tendency to move vertically and artifacts in the final row and column. &nbsp;We did not run into time constraints so the speed of the algorithm was not very important for our final decision.</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">Example maze generated with Eller&rsquo;s algorithm at 70x70 size:</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2 c13"><img height="577.0" src="images/image0.png" width="577.0"></p><p class="c2 c9"><a name="h.yvrewm-6jdxbd"></a><span class="c0 c3">Final Generator, Wilson&rsquo;s Algorithm with Post-Processing</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">Our goal for generating mazes is to make them difficult for the solver. &nbsp;Mazes that are easy for humans to solve are not necessarily easy for computers. &nbsp;To make the maze difficult to solve we had the following goals:</span></p><p class="c2"><span class="c0">&nbsp;</span></p><ol class="c14"><li class="c1" value="1"><span class="c0">Create a lot of opportunities for the computer to make mistakes with a lot of very short dead ends.</span></li><li class="c1"><span class="c0">Add loops to the maze so that dead-ends are more likely to be reached with a random traversal.</span></li><li class="c1"><span class="c0">Choose start and end points and optimal paths that are difficult for A* pathfinders to solve with the Manhattan distance heuristic.</span></li><li class="c1"><span class="c0">Do not use pre-made start or end points or patterns that can be used for a statistical solver.</span></li></ol><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">Our submission generates mazes in a two-pass process. &nbsp;First, a maze is generated with Wilson&rsquo;s Algorithm and then the maze is post-processed to make it more difficult for a computer solver to find a solution. &nbsp;The post-processor picks the worst possible endpoint for the maze&rsquo;s start point and begins removing walls between nearby paths on the maze.</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">Mazes are generated using a slightly modified version of the Wilson&rsquo;s algorithm generator. &nbsp;A random start location is chosen and the rest of the maze is generated.</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">The complete maze is passed to the post-processing step which first chooses a good endpoint for the maze. &nbsp;To find the optimal endpoint a complete search of the maze is performed to find the furthest possible point from the start. &nbsp;To create this a table of &ldquo;depth&rdquo; values, or distance from the start, is created for each node in the maze. &nbsp;Choosing the longest distance has the greatest possibility of being a long and winding path, and thus harder for the Manhattan distance heuristic to solve.</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">We re-use the depth table in the second part of post-processing to determine which walls to remove. &nbsp;A scan is performed from the top left corner of the maze to the bottom right corner, and if the node to the left or to the top of the current node is less than seven moves away the wall is removed.</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">This removes a lot of extraneous walls in the maze without changing the path for the optimal solution. &nbsp;The lack of walls make it more likely the solver to traverse dead-ends by giving it more opportunities to do so. </span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">Example maze generated with final algorithm at 70x70 size:</span></p><p class="c2 c13"><span class="c0 c3"></span><img height="577.0" src="images/image2.png" width="576.0"></p><p class="c2 c10"><a name="h.v6o0wk-mj22ij"></a><span class="c4 c3">Maze Solver</span></p><p class="c2 c9"><a name="h.2u4cnb-fn8l6a"></a><span class="c0 c3">Simple Solvers</span></p><p class="c2"><span class="c0">The first implementation of our solver was using a simple Breadth First Search. Breadth First Search was used primarily for its capability of finding the optimal solution every time despite being inefficient in the process. In the end, Breadth First Search was useful for gauging how well the other solvers are performing by giving us a benchmark for comparison.</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">Depth First Search was the next implementation which reduced memory usage and often found solutions in less time. Depth First Search gave us a quick and easy solver which we used to test out our early implementations of our generator. While Depth First Search performed better than Breadth First Search on average, it still tended to observe a significant amount of unnecessary nodes.</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">The natural progression of Depth First Search was Bidirectional Depth First Search. With Bidirectional Search we noticed a consistent increase in performance to Depth First Search. By maintaining two frontiers the chances of running into an existing path improved the average solution time. With this in mind, it was a clear indication that a Bidirectional Search would improve our solver.</span></p><p class="c2 c9"><a name="h.9nb9fx-jlbyu3"></a><span class="c0 c3">Solvers with Heuristics</span></p><p class="c2"><span class="c0">The next bidirectional search we worked with was a simple A* search. The heuristic used in our bidirectional search was the use of Manhattan Distance from the start position towards the end position. The addition of this heuristic significantly increased the accuracy of our solver since it was much easier for both of our frontiers to find each other by going towards the same general direction.</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">Continuing to improve on our A* search, the next step was having the heuristic score the shortest distance from each node to the other&rsquo;s frontier. By recalculating our heuristic every time the frontier changed we allowed each side of our search to adapt itself as the other side of the solver moved in its own manner. Having both of our frontiers actively seeking each other further improved the accuracy of our searches. </span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">A problem that came up with this search, however, was the amount of computation required in order to recalculate the distance from all of the frontier nodes of one side with that of the opposite side. As mazes get bigger, the amount of computations required would lead to O(</span><img src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=%7Bn%7D%5E%7B2%7D"><span class="c0">) time complexity every time we expand the frontier. To remedy this we approximate the best score by only calculating the heuristic once, against the last position on the other frontier, for each node in the active frontier. This optimization reduced complexity down to O(</span><img src="https://www.google.com/chart?cht=tx&amp;chf=bg,s,FFFFFF00&amp;chco=000000&amp;chl=n"><span class="c0">) time. </span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2 c9"><a name="h.xr6wbj-qvybi8"></a><span class="c0 c3">Final Solver, Adaptive A* </span></p><p class="c2"><span class="c0">The final version of our bidirectional A* search was inspired by the following beliefs:</span></p><ol class="c15"><li class="c1" value="1"><span class="c0">Frontier nodes should always be trying to find each other,</span></li><li class="c1"><span class="c0">Manhattan distance gives an accurate representation of the general direction that should be explored, </span></li><li class="c1"><span class="c0">Statistics should be used to notice patterns in the types of mazes being generated. </span></li></ol><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">Having had a good deal of success with our recently created A* search, we felt it necessary to add more aid to our heuristic while not breaking what was already working. As a result, we continue to use Manhattan Distance as the primary source for our search while using the statistics to guide our decisions further. </span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">After each maze has been solved, statistics are gathered based on what nodes were traversed to reach the answer. Every subsequent maze traversed then uses this data in order to make an informed decision about the types of paths the maze will tend to create. A weight is then associated with the statistics, so as to not rely too heavily on this uncertain data.</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">To determine the amount of weight that would be placed on the statistics, we ran many different tests using different types and sizes of mazes. We found that the more difficult mazes tended to cause problems with our statistics. The more we focused on our statistics, the more often we would end up hurting the heuristic for important nodes. As a result, the weight that tended to give the most favorable results on a variety of different maze types was 25%.</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">This is a graph using the standard Wilson&rsquo;s algorithm generator:</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2 c13"><img height="463.0" src="images/image4.png" width="600.0"></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">This is a graph using our final generator:</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2 c13"><img height="463.0" src="images/image1.png" width="600.0"></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">Shown here are the statistics we obtained from running all of our solvers against our Final Wilson Generator: </span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">Width: 500 Height: 500</span></p><p class="c2"><span class="c0">Number of iterations: 100</span></p><p class="c2"><span class="c0">Adaptive AStar Weight = 0.25</span></p><p class="c2"><span class="c0">=========================== SCORES ==========================</span></p><p class="c2"><span class="c0">BreadthFirst: 246557.27</span></p><p class="c2"><span class="c0">DepthFirst: 130232.266</span></p><p class="c2"><span class="c0">BidirectionalDepth: 96531.72</span></p><p class="c2"><span class="c0">AStarSimple: 116034.75</span></p><p class="c2"><span class="c0">AStar: 83457.625</span></p><p class="c2"><span class="c0">AdaptiveAStar: 83955.75</span></p><p class="c2"><span class="c0">=============================================================</span></p><p class="c2"><span class="c0">Performance of Adaptive A* = 0.60% worse</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">Width: 500 Height: 500</span></p><p class="c2"><span class="c0">Number of iterations: 100</span></p><p class="c2"><span class="c0">Adaptive AStar Weight = 0.5</span></p><p class="c2"><span class="c0">=========================== SCORES ==========================</span></p><p class="c2"><span class="c0">BreadthFirst: 246397.92</span></p><p class="c2"><span class="c0">DepthFirst: 131276.44</span></p><p class="c2"><span class="c0">BidirectionalDepth: 86539.22</span></p><p class="c2"><span class="c0">AStarSimple: 118396.33</span></p><p class="c2"><span class="c0">AStar: 90284.59</span></p><p class="c2"><span class="c0">AdaptiveAStar: 90461.22</span></p><p class="c2"><span class="c0">=============================================================</span></p><p class="c2"><span class="c0">Performance of Adaptive A* = 0.2% worse</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">Width: 500 Height: 500</span></p><p class="c2"><span class="c0">Number of iterations: 100</span></p><p class="c2"><span class="c0">Adaptive AStar Weight = 0.75</span></p><p class="c2"><span class="c0">=========================== SCORES ==========================</span></p><p class="c2"><span class="c0">BreadthFirst: 246411.06</span></p><p class="c2"><span class="c0">DepthFirst: 129082.35</span></p><p class="c2"><span class="c0">BidirectionalDepth: 90852.164</span></p><p class="c2"><span class="c0">AStarSimple: 121328.086</span></p><p class="c2"><span class="c0">AStar: 90211.88</span></p><p class="c2"><span class="c0">AdaptiveAStar: 89287.8</span></p><p class="c2"><span class="c0">=============================================================</span></p><p class="c2"><span class="c0">Performance of Adaptive A* = 1.03% better</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">The increased weight resulted in better scores against our improved generator, but we decided against increasing the weight because we do not believe our competitor&#39;s generators will be as harsh as ours.</span></p><p class="c2 c10"><a name="h.d1koev-97lhqn"></a><span class="c4 c3">Team Contributions</span></p><p class="c2 c9"><a name="h.o656ah-942ut"></a><span class="c0 c3">Peter Huynh</span></p><ol class="c14"><li class="c1" value="1"><span class="c0">Initial work on the maze generator.</span></li><li class="c1"><span class="c0">Implemented the Eller maze generator.</span></li></ol><p class="c2 c9"><a name="h.uwhotl-tppa26"></a><span class="c0 c3">Jeff McGlynn</span></p><ol class="c14"><li class="c1" value="1"><span class="c0">Wilson maze generator algorithm.</span></li><li class="c1"><span class="c0">Post-processing maze generation step for final generator.</span></li></ol><p class="c2 c9"><a name="h.ilrpts-8sn0qy"></a><span class="c0 c3">Jesus Quezada</span></p><ol class="c14"><li class="c1" value="1"><span class="c0">Breadth / Depth First Search.</span></li><li class="c1"><span class="c0">A* Search using heuristics.</span></li><li class="c1"><span class="c0">Bidirectional A* Search using statistics.</span></li></ol><p class="c2"><span class="c0">&nbsp;</span></p><p class="c2"><span class="c0">Peter worked with us at the beginning of the project but was unable to continue working on it until the end. &nbsp;No code written by Peter is included in the final product but his ideas may be included in the project.</span></p><p class="c2 c10"><a name="h.lx73ll-9kfkr9"></a><span class="c3 c4">Sources</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c5"><span class="c0">&quot;Dijkstra&#39;s algorithm.&quot; </span><span class="c0 c8">Wikipedia, The Free Encyclopedia</span><span class="c0">. Wikipedia, The Free Encyclopedia, 23 Nov. 2010. Web. 29 Nov. 2010. &lt;http://en.wikipedia.org/wiki/Dijkstra&#39;s_algorithm&gt;.</span></p><p class="c2"><span class="c0">&nbsp;</span></p><p class="c5"><span class="c0">&quot;Loop-erased random walk.&quot; </span><span class="c0 c8">Wikipedia, The Free Encyclopedia</span><span class="c0">. Wikipedia, The Free Encyclopedia, 9 Aug. 2010. Web. 29 Nov. 2010. &lt;http://en.wikipedia.org/wiki/Loop-erased_random_walk&gt;.</span></p><p class="c5"><span class="c0">&nbsp;</span></p><p class="c5"><span class="c0">&quot;Maze generation algorithm.&quot; </span><span class="c0 c8">Wikipedia, The Free Encyclopedia</span><span class="c0">. &nbsp;Wikipedia, The Free Encyclopedia, 15 Nov. 2010. Web. 29 Nov. 2010. &nbsp;&lt;http://en.wikipedia.org/wiki/Maze_generation_algorithm&gt;.</span></p><p class="c5"><span class="c0">&nbsp;</span></p><p class="c5"><span class="c0">Pullen, Walter D. &quot;Maze Algorithms.&quot; </span><span class="c0 c8">Think Labyrinth</span><span class="c0">. N.p., 02 Sep 2009. Web. 28 Nov 2010.</span></p><p class="c5"><span class="c0">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;http://www.astrolog.org/labyrnth/algrithm.htm&gt;.</span></p><p class="c5"><span class="c0">&nbsp;</span></p><p class="c5"><span class="c0">Russel, Stuart, and Peter Norvig. </span><span class="c0 c8">Artificial Intelligence: A Modern Approach</span><span class="c0">. Third Edition. Pearson Education, Inc., 2010. 64-109. Print.</span></p></body></html>